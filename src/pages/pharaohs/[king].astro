---
import Layout from "@/layouts/Layout.astro";
import pharaohs from "@/data/pharaohs.json";
import hieroglyphs from "@/data/hieroglyphics.json";
import dynasties from "@/data/dynasties.json";
import titulary from "@/data/titulary.json";
import authors from "@data/pharaohs_man.json";

// Transliterate function
function Translit(inn: string): string {
	const translitMap: Record<string, string> = {
		A: "Ꜣ",
		a: "Ꜥ",
		D: "ḏ",
		x: "ḫ",
		X: "ẖ",
		q: "ḳ",
		T: "ṯ",
		S: "š",
		H: "ḥ",
		j: "ꞽ",
		ii: "y",
	};
	return Object.keys(translitMap).reduce((str, key) => str.replaceAll(key, (translitMap as Record<string, string>)[key]), inn);
}

export async function getStaticPaths() {
	return pharaohs.map((p) => ({
		params: { king: p.slug },
		props: { pharaoh: p },
	}));
}

const { pharaoh } = Astro.props;

// Find all hieroglyphs for this pharaoh (matching 'no' to 'farao')
const phNo = Number(pharaoh.no);
const glyphs = hieroglyphs.filter((h) => h.farao === phNo);

// Group by 'titel'
const glyphGroups: Record<string, any[]> = {};
for (const glyph of glyphs) {
	const key = glyph.titel;
	if (!glyphGroups[key]) glyphGroups[key] = [];
	glyphGroups[key].push(glyph);
}

/* These will be sent to Layout for page name and meta tags */
const title = pharaoh.name;
const meta1 = pharaoh.meta1;
const meta2 = pharaoh.meta2;
const bild = pharaoh.image;
// Compute a stable dynasty URL. dynasties.json contains most slugs (numeric and named).
function getDynURL(dyn: string | number | undefined): string {
	const raw = dyn == null ? "unplaced" : String(dyn);
	// Direct match: some dynasties use numeric slugs ("1", "2", ...)
	const bySlug = dynasties.find((d: any) => d.slug === raw);
	if (bySlug) return `/dynasty/${bySlug.slug}`;

	// Known special numeric codes that map to named slugs
	const special: Record<string, string> = {
		"0": "predynastic",
		"32": "argead",
		"33": "ptolemaic",
		"34": "roman-pharaohs",
		"35": "abydos",
		"36": "unplaced-kings",
	};
	if (special[raw]) return `/dynasty/${special[raw]}`;

	// Fallback: encode and use raw value (keeps link predictable)
	return `/dynasty/${encodeURIComponent(raw)}`;
}

// Resolve the canonical dynasty slug (honours numeric special codes), then derive URL + name
function resolveDynSlug(dyn: string | number | undefined): string {
    const raw = dyn == null ? "unplaced" : String(dyn);
    const bySlug = dynasties.find((d: any) => d.slug === raw);
    if (bySlug) return bySlug.slug;
    const special: Record<string, string> = {
        "0": "predynastic",
        "32": "argead",
        "33": "ptolemaic",
        "34": "roman-pharaohs",
        "35": "abydos",
        "36": "unplaced-kings",
    };
    if (special[raw]) return special[raw];
    return raw;
}

const dynSlug = resolveDynSlug(pharaoh.dynasty);
const dynURL = `/dynasty/${dynSlug}`;
const dynObj = dynasties.find((d: any) => d.slug === dynSlug);
const dynName = dynObj ? dynObj.name : String(pharaoh.dynasty);

// Helper: find a pharaoh object by its 'no' or slug
function findPharaohByRef(ref: string | number | undefined) {
	if (ref == null || ref === "") return null;
	const refStr = String(ref);
	// try matching by 'no' first (pharaohs use 'no' for numeric identifier)
	let p = pharaohs.find((x: any) => String(x.no) === refStr);
	if (p) return p;
	// fallback: try slug
	p = pharaohs.find((x: any) => String(x.slug) === refStr);
	return p ?? null;
}

// Generate link HTML for a predecessor/successor reference
function refLinkHtml(ref: string | number | undefined) {
	// Treat 0 (numeric or string) as 'no predecessor/successor' — return blank
	if (ref === 0 || ref === '0') return '';
	const p = findPharaohByRef(ref);
	if (!p) return String(ref ?? '');
	const url = `/pharaohs/${p.slug}`;
	return `<a href="${url}">${p.name}</a>`;
}

// Convert an integer order into an ordinal word (1 -> 'first', 2 -> 'second', ...)
function ordinalWord(n: number | string) {
	const num = Number(n);
	if (!Number.isFinite(num) || num <= 0) return String(n ?? "");
	const map: Record<number, string> = {
		1: "first",
		2: "second",
		3: "third",
		4: "fourth",
		5: "fifth",
		6: "sixth",
		7: "seventh",
		8: "eighth",
		9: "ninth",
		10: "tenth",
		11: "eleventh",
		12: "twelfth",
		13: "thirteenth",
		14: "fourteenth",
		15: "fifteenth",
		16: "sixteenth",
		17: "seventeenth",
		18: "eighteenth",
		19: "nineteenth",
		20: "twentieth",
		70: "uncertain",
	};
	if (map[num]) return map[num];
	// fallback to ordinal suffix if out of map range
	const suffix = (v: number) => {
		const tens = v % 100;
		if (tens >= 11 && tens <= 13) return "th";
		switch (v % 10) {
			case 1:
				return "st";
			case 2:
				return "nd";
			case 3:
				return "rd";
			default:
				return "th";
		}
	};
	return `${num}${suffix(num)}`;
}

// Display order with awareness of legacy 'uncertain' codes (>69) and new fields
function displayOrder(p: any) {
	// Prefer explicit new field if present
	if (p.order_estimate && Number.isFinite(Number(p.order_estimate))) {
		return ordinalWord(p.order_estimate);
	}
	// If an explicit uncertain flag exists, show a friendly message
	if (p.order_uncertain) {
		// If there's a note (e.g., original code), include it
		if (p.order_note) return `position uncertain (${p.order_note})`;
		return 'position uncertain';
	}
	// If legacy numeric order exists, interpret it: treat >69 as uncertain marker
	const ord = Number(p.order);
	if (Number.isFinite(ord) && ord > 0 && ord <= 69) return ordinalWord(ord);
	if (Number.isFinite(ord) && ord > 69) return 'position uncertain';
	// Fallback: show raw value or empty
	return p.order ?? '';
}

// Returns true when legacy codes (>69) or explicit flags indicate uncertainty
function isOrderUncertain(p: any) {
	if (p.order_uncertain) return true;
	const ord = Number(p.order);
	if (Number.isFinite(ord) && ord > 69) return true;
	return false;
}

// Map of reign field keys to friendly labels
const reignLabels: Record<string, string> = {
	r_consensus: "",
	r_turin: "Turin King List",
	r_hornung: "Hornung",
	r_shaw: "Shaw",
	r_redford: "Redford",
	r_malek: "Malek",
	r_beckerath: "von Beckerath",
	r_baker: "Baker",
	r_dodson: "Dodson",
	r_arnold: "Arnold",
	r_grimal: "Grimal",
	r_lepsius: "Lepsius",
	r_abydos: "Abydos Canon",
	r_saqqara: "Saqqara Canon",
	r_karnak: "Karnak Canon",
	r_africanus: "Manetho (Africanus)",
	r_eusebius: "Manetho (Eusebius)",
	r_manetho: "Manetho",
	r_josephus: "Josephus",
	r_jerome: "Manetho (Jerome)",
	r_highestyear: "Highest attestation",
	// fallback: other r_... keys will be shown with stripped prefix and underscores replaced
};

// Replace 'KRI,' with full expanded text in source strings (case-sensitive)
function replaceKRI(src: string | undefined) {
	if (!src) return src;
	return src.replace("KRI,", "Kitchen, <i>Ramesside Inscriptions</i>, ");
}

let m1 =
	`The hieroglyphs of ${pharaoh.name}, including rare variants, with detailed descriptions of the titles and the sources of the name. ${pharaoh.aka}`;

let m2 =
	`pharaoh,hieroglyphs,hieroglyphics,pharaoh of Egypt,king of Egypt,Egyptian chronology,hieroglyphic titles,royal egyptian titles,titles of pharaoh,${pharaoh.name},hieroglyphs of ${pharaoh.name},pharaoh,hieroglyphs of ${pharaoh.name},royal titulary egypt,fivefold name,${pharaoh.aka}`;

// Prepare matches from pharaohs_man (authors) where authors.ph == current pharaoh no
const antiquityMatches = (authors ?? []).filter((a: any) => Number(a.ph) === phNo);

// Map of author numeric codes to human-readable names
const authorArray = [
	0,
	"Africanus",
	"Eusebius",
	"Jerome",
	"Josephus",
	"Herodotus",
	"Diodorus",
	"Eratosthenes",
	"The Bible",
];

// Helper to render matched entries as an HTML table (used in template via set:html)
function antiquityTableHtml(entries: any[]) {
	if (!entries || entries.length === 0) return "";
	const rows = entries
		.map((e) => {
			const authorName = authorArray[Number(e.author)] ?? (e.author ?? "");
			const ch = e.ch ?? "";
			const greek = e.greek ?? "";
			const tscript = e.tscript ?? "";
			const reign = e.reign ?? "";
			return `
				<tr>
					<td class="px-2 py-1 align-top">${authorName} &nbsp; <sub>${ch}</sub></td>
					<td class="px-2 py-1 align-top gr">${greek}</td>
					<td class="px-2 py-1 align-top">${tscript}</td>
					<td class="px-2 py-1 align-top">${reign || '&ndash;'}</td>
				</tr>`;
		})
		.join("");

	return `
		<div class="overflow-x-auto">
			<table class="w-full text-sm border-collapse">
				<thead>
					<tr class="text-left">
						<th class="border-b pb-2">Author</th>
						<th class="border-b pb-2">Greek</th>
						<th class="border-b pb-2">Transcription</th>
						<th class="border-b pb-2">Reign</th>
					</tr>
				</thead>
				<tbody>
					${rows}
				</tbody>
			</table>
		</div>`;
}


---

<Layout title={title} meta1={m1} meta2={m2} bild={bild}>
	{
		/** Titulary lookup available to template rendering */
		(() => {
			const myTitulary = titulary.filter((t) => Number(t.farao) === phNo);
			function titularyBy(titelNum: number) {
				return myTitulary.find((t) => Number(t.titel) === Number(titelNum));
			}
			// expose helpers via a symbol on the closure
			(Astro as any).__titularyHelpers = { myTitulary, titularyBy };
			return null;
		})()
	}
	<!-- <h1 class="text-3xl font-bold pb-4">{pharaoh.name}</h1> -->
	{
		isOrderUncertain(pharaoh) ? (
			<div class="my-4">A king whose position is uncertain{pharaoh.aka && <span>, also known as <i> {pharaoh.aka}</i></span>}</div>
		) : (
			<div class="my-4">The {displayOrder(pharaoh)} pharaoh of the <a href={dynURL}>{dynName}</a> {pharaoh.aka && <span>, also known as <i> {pharaoh.aka}</i></span>}</div>
		)
	}

	
	{
		pharaoh.reigns && pharaoh.reigns.length > 0 && (
			<section class="pl-4 pb-4 float-right">
				{pharaoh.reigns.map((r) => {
					return (
						<div class="card px-2 py-4">
							<div class="text-center mb-4" set:html={`
								<p class="text-sm m-0">Predecessor</p>
								<p class="m-0"> ${refLinkHtml(pharaoh.prev)}</p>
								<p class="pt-4 text-sm m-0">Successor</p>
								<p class="m-0"> ${refLinkHtml(pharaoh.next)}</p>`} />
							<div class="mb-0 text-sm border-b text-center">
								Reign of <span class="font-semibold primary">{pharaoh.name}</span>
							</div>
							<div class="text-xs font-normal">
								<table class="my-0">
									{Object.entries(r)
										.filter(([k]) => k !== "id")
										.map(([k, v]) => {
											const label = reignLabels[k] ?? k.replace(/^r_/, "").replace(/_/g, " ");
											return (
												<>
													<tr>
														<td class="text-xs">{label}</td>
														<td class="text-xs tabular-nums">{String(v)}</td>
													</tr>
												</>
											);
										})}
								</table>
							</div>
						</div>
					);
				})}
			</section>
		)
	}
	{pharaoh.description && <article class="mt-4" set:html={pharaoh.description} />}

	<section class="clear-both mt-8">
		<h2 class="text-4xl font-bold text-center border-t bordercolor pt-4">The Royal Titulary</h2>
		<p class="mt-0 text-center pb-6">From the hieroglyphic records</p>
	</section>

	{
		(() => {
			const myTitulary = titulary.filter((t) => Number(t.farao) === phNo);
			const t1 = myTitulary.find((t) => Number(t.titel) === 1);
			const t4 = myTitulary.find((t) => Number(t.titel) === 4);
			const t5 = myTitulary.find((t) => Number(t.titel) === 5);
			if (!t1 && !t4 && !t5) return null;
			return (
				<section class="mt-10 clear-both">
					
					<div class="flex items-center justify-center gap-2 mb-2">
						{t1 && <img src={`/svg/pharaoh/${t1.glyph}.svg`} alt={t1.gname} class="h-12 dark:invert" />}
						{t4 && <img src="/svg/hiero/t_nesut.svg" alt="nesut" class="h-12 dark:invert pl-4" />}
						{t4 && <img src={`/svg/pharaoh/${t4.glyph}.svg`} alt={t4.gname} class="h-12 dark:invert" />}
						{t5 && <img src="/svg/hiero/t_sara.svg" alt="sa Ra" class="h-12 dark:invert pl-4" />}
						{t5 && <img src={`/svg/pharaoh/${t5.glyph}.svg`} alt={t5.gname} class="h-12 dark:invert" />}
					</div>
					<div class="text-center space-y-1">
						{t1 && <span class="font-light text-xs italic">Horus</span> <span>{t1.gname}&nbsp; &nbsp;</span>}
						{t4 && <span class="font-light text-xs italic pl-4">The Dual King</span> <span set:html={t4.gname} />}
						{t5 && <span class="font-light text-xs italic pl-4">Son of Ra</span> <span set:html={t5.gname} />}
					</div>
				</section>
			);
		})()
	}
	{
		Object.keys(glyphGroups).length > 0 && (
			<section class="mt-8 clear-both">
				{Object.entries(glyphGroups).map(([titel, glyphs]) => {
					const titelMap = [
						"", // 0 (unused)
						`<div><h2 class="text-center pt-10 pb-2 text-3xl text-red-800 dark:text-amber-200">Horus</h2><img src="/svg/hiero/t_horus.svg" loading="lazy" class="h-20 dark:invert mx-auto" alt="Horus name"><p class="w-2/3 mx-auto text-center color-2 text-sm/tight text-balance pb-8">The oldest form of the name of a pharaoh, a falcon representing Horus is perched on the palace facade.</p></div>`, // 1
						`<div><h2 class="text-center pt-10 pb-2 text-3xl text-red-800 dark:text-amber-200">Nebty</h2><img src="/svg/hiero/t_nebty.svg" loading="lazy" class="h-20 dark:invert mx-auto" alt="Nebty name"><p class="w-2/3 mx-auto text-center color-2 text-sm/tight text-balance pb-8">The “Two Ladies”, the <i>goddesses Nekhbet and Wadjet</i>, representing Upper and Lower Egypt respectively.</p></div>`, // 2
						`<div><h2 class="text-center pt-10 pb-2 text-3xl text-red-800 dark:text-amber-200">Golden Horus</h2><img src="/svg/hiero/t_gold.svg" loading="lazy" class="h-20 dark:invert mx-auto" alt="Golden Horus name"><p class="w-2/3 mx-auto text-center color-2 text-sm/tight text-balance pb-8">Horus perched on Gold, which was associated with eternity, but its meaning is disputed.</p></div>`, // 3
						`<div><h2 class="text-center pt-10 pb-2 text-3xl text-red-800 dark:text-amber-200">Throne name</h2><img src="/svg/hiero/t_nesut.svg" loading="lazy" class="h-20 dark:invert mx-auto" alt="Prenomen or throne name"><p class="w-2/3 mx-auto text-center color-2 text-sm/tight text-balance pb-8">Announced at the coronation and always written in a cartouche. The “official” name of the pharaoh. Also known as the <i>Prenomen</i>.</p></div>`, // 4
						`<div><h2 class="text-center pt-10 pb-2 text-3xl text-red-800 dark:text-amber-200">Birth name</h2><img src="/svg/hiero/t_sara.svg" loading="lazy" class="h-20 dark:invert mx-auto" alt="Nomen or birth name"><p class="w-2/3 mx-auto text-center color-2 text-sm/tight text-balance pb-8">Personal name given at birth. Also known as the <i>Nomen</i>.</p></div>`, // 5
						``, // 6
						`<div><h2 class="text-center pt-10 pb-2 text-3xl text-red-800 dark:text-amber-200">Throne + Birth name</h2><p class="w-2/3 mx-auto text-center color-2 text-sm/tight text-balance pb-8">Combined Throne and Birth name.</p>`, // 7
						`<div><h2 class="text-center pt-10 pb-2 text-3xl text-red-800 dark:text-amber-200">Autokrator</h2><p class="w-2/3 mx-auto text-center color-2 text-sm/tight text-balance pb-8">The Greek epithet <i class="font-semibold">Autokrator</i> is the equivalent of the Latin epithet <i class="font-semibold">Imperator</i> (Commander).<br>It was always written in the cartouche.</p></div>`, // 8
						`<div><h2 class="text-center pt-10 pb-2 text-3xl text-red-800 dark:text-amber-200">Kaisaros</h2><p class="w-2/3 mx-auto text-center color-2 text-sm/tight text-balance pb-8">The Greek title Kaisaros is the equivalent of the Latin title <i class="font-semibold">Caesar</i>.<br />It was always written in a cartouche.</p>`, // 9
						`<div><h2 class="text-center pt-10 pb-2 text-3xl text-red-800 dark:text-amber-200">Autokrator & Kaisaros</h2><p class="w-2/3 mx-auto text-center color-2 text-sm/tight text-balance pb-8">The Greek title <i>Kaisaros</i> = the Latin title <i>Caesar</i>.<br>The Greek epithet <i>Autokrator</i> = the Latin <i>Imperator</i>.</p>`, // 10
					];
					const titelLabel = titelMap[Number(titel)] || titel;
					return (
						<div class="mb-6">
							<div set:html={titelLabel} />
							<div class="grid gap-4">
								{((glyphs as any[]) ?? []).map((g) => (
									<div class="card">
										<div class="mt-1">
											<img src={`/svg/pharaoh/${g.hiero}.svg`} alt={g.name} class="dark:invert h-14 max-h-24 my-2" />
										</div>
										{g.name && (
											<div
												class="hieroname"
												set:html={
													g.name.endsWith("*")
														? `${g.name.slice(0, -1)}<abbr class="opacity-50 no-underline" title=\"Not contemporaneous, later designation.\">*</abbr>`
														: g.name
												}
											/>
										)}
										{g.tlit && <div class="text-sm tlit" set:html={Translit(g.tlit)} />}
										{g.translation && <div class="text-sm">{g.translation}</div>}
										<div
											class="border-t mt-2 pt-2 text-xs bibliography"
											set:html={[
												replaceKRI(g.source),
												g.lepsius && `Lepsius, <i>Denkmäler aus Ägypten und Äthiopien</i>, ${g.lepsius}`,
												g.beckerath && `Beckerath, “Handbuch der ägyptischen Königsnamen”, 2nd ed. <i>MÄS</i> <b>49</b> (1999). ${g.beckerath}`,
												g.turin && `Turin King List: ${g.turin}`,
												g.gardiner && `Gardiner, <i>The Royal Canon of Turin</i> (1959): ${g.gardiner}`,
												g.abydos && `Abydos Canon No. ${g.abydos}`,
												g.saqqara && `Saqqara Canon No. ${g.saqqara}`,
												g.karnak && `Karnak Canon No. ${g.karnak}`,
											]
												.filter(Boolean)
												.join("<br>")}
										/>
									</div>
								))}
							</div>
						</div>
					);
				})}
			</section>
		)
	}

{
	(() => {
		if (!antiquityMatches || antiquityMatches.length === 0) return null;
		return (
			<section class="my-20">
				<h2 class="text-3xl font-semibold mb-4 text-center">The sources of antiquity</h2>
				<p class="text-sm opacity-70 mb-2 text-center">From the writings of the historians and scholars of antiquity</p>
				<div set:html={antiquityTableHtml(antiquityMatches)} />
			</section>
		);
	})()
}

<!-- Bibliography -->
{/** Render bibliography from pharaoh fields if present */}

{
	(() => {
		const bibFields = ["G17", "G18", "G19", "G20", "G21", "VON", "LPR", "DDB"];
		// Define a mapping of field keys to prefix strings
		const fieldPrefixes = {
			G17: "<b>Gauthier, H.</b> Le livre des rois d'Égypte. <i>MIFAO</i> <b>17</b> (1907): ",
			G18: "<b>Gauthier, H.</b> Le livre des rois d'Égypte. <i>MIFAO</i> <b>18</b> (1912): ",
			G19: "<b>Gauthier, H.</b> Le livre des rois d'Égypte. <i>MIFAO</i> <b>19</b> (1913): ",
			G20: "<b>Gauthier, H.</b> Le livre des rois d'Égypte. <i>MIFAO</i> <b>20</b> (1915): ",
			G21: "<b>Gauthier, H.</b> Le livre des rois d'Égypte. <i>MIFAO</i> <b>21</b> (1917): ",
			VON: "<b>Beckerath, J.</b>, 1999. “Handbuch der ägyptischen Königsnamen”, Second edition, <i>MÄS</i> <b>49</b> (1999): ",
			LPR: "<b>Leprohon, R. J.</b>, 2013. <i>The Great Name: Ancient Egyptian Royal Titulary</i>. ",
			DDB: "<b>Baker. D. D.</b>, 2008. <i>The Encyclopedia of the Pharaohs: Volume I</i>. ",
		};
		const entries: { key: string; value: string }[] = [];
		for (const f of bibFields) {
			const val = (pharaoh as any)[f];
			if (val) entries.push({ key: f, value: val });
		}
		if (entries.length === 0) return null;
		return (
			<section class="my-12">
				<h2 class="text-3xl font-semibold mb-4 text-center">Bibliography</h2>
				<ul class="list-none pl-6 text-sm leading-loose">
					{entries.map(({ key, value }) => {
						const prefix = fieldPrefixes[key as keyof typeof fieldPrefixes] || "";
						// Build the raw HTML string for the <li> content (prefix + value only)
						const liContent = prefix + value;
						return <li set:html={liContent}></li>;
					})}
				</ul>
			</section>
		);
	})()
}


			<div class="mx-auto px-7 py-3 my-16 text-stone-800/75 dark:text-neutral-300/75 border w-fit text-center bg-light bordercolor rounded-xl text-sm">
				<b class="text-black dark:text-white">PLEASE NOTE</b><br>
				There <i>might</i> be errors on this page.<br>
				Make sure you use the <span class="text-black dark:text-neutral-100">correct source!</span>
				
			</div>

</Layout>

<style>
	.hieroname {
		font-size: var(--text-2xl);
		font-weight: var(--font-weight-light);
		i {
			font-style: italic;
			font-size: var(--text-xl);
			color: light-dark(var(--dim), var(--dark-dim));
		}
	}
</style>

